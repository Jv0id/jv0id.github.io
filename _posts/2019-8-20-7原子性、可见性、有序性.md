---
layout: post
title: "7原子性、可见性、有序性"
key: 并发
tags: 并发
author: Jv0id
---



### 原子性

- 原子性是指**一个操作是不可中断的，要么全部执行成功要么全部执行失败，有着“同生共死”的感觉**。
- 在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。

```java
int a = 10; //1

a++; //2

int b=a; //3

a = a+1; //4

/*
上面这四个语句中只有第1个语句是原子操作，将10赋值给线程工作内存的变量a

而语句2（a++），实际上包含了三个操作：1. 读取变量a的值；2：对a进行加一的操作；3.将计算后的值再赋值给变量a，而这三个操作无法构成原子操作。

对语句3,4的分析同理可得这两条语句不具备原子性
*/
```

#### java内存模型中8个原子性操作

- **lock(锁定)**：作用于主内存中的变量，它把一个变量标识为一个线程独占的状态
- **unlock(解锁)**:作用于主内存中的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
- **read（读取）**：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便后面的load动作使用
- **load（载入）**：作用于工作内存中的变量，它把read操作从主内存中得到的变量值放入工作内存中的变量副本
- **use（使用）**：作用于工作内存中的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作
- **assign（赋值）**：作用于工作内存中的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作
- **store（存储）**：作用于工作内存的变量，它把工作内存中一个变量的值传送给主内存中以便随后的write操作使用
- **write（操作）**：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中





- 把一个变量从主内存中复制到工作内存中就需要执行read,load操作
- 将工作内存同步到主内存中就需要执行store,write操作
- 注意的是：**java内存模型只是要求上述两个操作是顺序执行的并不是连续执行的**
- read和load之间可以插入其他指令，store和writer可以插入其他指令。
- 原子性变量操作read,load,use,assign,store,write，**大致认为基本数据类型的访问读写具备原子性**（例外就是long和double的非原子性协定）
- 如果我们需要更大范围的原子性操作就可以使用lock和unlock原子操作。
- **synchronized满足原子性**。
- 如果让volatile保证原子性，必须符合以下两条规则：**运算结果并不依赖于变量的当前值，或者能够确保只有一个线程修改变量的值**；**变量不需要与其他的状态变量共同参与不变约束**



### 有序性

- synchronized语义表示锁在同一时刻只能由一个线程进行获取，当锁被占用后，其他线程只能等待。
- 因此，synchronized语义就要求线程在访问读写共享变量时只能“串行”执行，因此**synchronized具有有序性**
- java程序天然的有序性可以总结为：**如果在本线程内观察，所有的操作都是有序的；如果在一个线程观察另一个线程，所有的操作都是无序的**。
- 双重检验锁定的方式（Double-checked Locking）

```java
public class Singleton {
    private Singleton() { }
    private volatile static Singleton instance;
    public Singleton getInstance(){
        if(instance==null){
            synchronized (Singleton.class){
                if(instance==null){
                    instance = new Singleton();//这条语句实际上包含了三个操作：1.分配对象的内存空间；2.初始化对象；3.设置instance指向刚分配的内存地址。
                }
            }
        }
        return instance;
    }
}

```

[执行顺序](https://user-gold-cdn.xitu.io/2018/5/3/1632600e7b66b892?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

- 如果2和3进行了重排序的话，线程B进行判断if(instance==null)时就会为true，而实际上这个instance并没有初始化成功，显而易见对线程B来说之后的操作就会是错得。而**用volatile修饰**的话就可以禁止2和3操作重排序，从而避免这种情况。**volatile包含禁止指令重排序的语义，其具有有序性**。



### 可见性

- 可见性是指当一个线程修改了共享变量后，其他线程能够立即得知这个修改。
- 当线程获取锁时会从主内存中获取共享变量的最新值，释放锁的时候会将共享变量同步到主内存中。
- **synchronized具有可见性**
- 通过在指令中添加**lock指令**，以实现内存可见性。因此, **volatile具有可见性**

### 总结

- **synchronized: 具有原子性，有序性和可见性**； **volatile：具有有序性和可见性**

[原文](https://juejin.im/post/5aeb022cf265da0b722af7b8)
