---
title: "各种好用的Map"
layout: post
date: 2019-11-21 10:20
headerImage: false
tag:
- map
- 好用
category: blog
author: 夏潇熙
description: 各种好用的Map
---

### 1. 双向map：DualHashBidiMap

DualHashBidiMap可以通过key找到value，也可以通过value找到key
> org.apache.commons.collections.bidimap.DualHashBidiMap

```java
@Test
public void testDualHashBidiMap(){
    //双向map
    BidiMap bidiMap = new DualHashBidiMap();
    bidiMap.put("Ay", "Boy");
    bidiMap.put("Al", "Girl");
    System.out.println("Key-Value:Ay = " + bidiMap.get("Ay"));//Key-Value:Ay = Boy
    System.out.println("Value-Key:Gril = " + bidiMap.getKey("Girl"));//Value-Key:Gril = Al
}
```

### 2.一对多map：MultiMap

MultiMap：一个key不在是简单的指向一个对象，而是一组对象

```java
@Test
public void testMultiMap(){
    //MultiHashMap已经废弃
    MultiMap giftMap = new MultiHashMap();
    giftMap.put("gift", "鲜花");
    giftMap.put("gift", "戒指");
    giftMap.put("gift", "伞");
    List list = (List) giftMap.get("gift");
    System.out.println(list);//[鲜花, 戒指, 伞]

    MultiMap giftMap2 = new MultiValueMap();
    giftMap2.put("gift", "鲜花");
    giftMap2.put("gift", "戒指");
    giftMap2.put("gift", "伞");
    giftMap2.put("boy","ay");
    giftMap2.put("girl","al");
    List list2 = (List) giftMap2.get("gift");
    List list3 = (List)giftMap2.get("boy");
    System.out.println(list2);//[鲜花, 戒指, 伞]
    System.out.println(list3);//[ay]

}
```

### 3.固定大小map：LRUMap

LRUMap：大小固定。它不是同步的，也不是线程安全的,新增的元素个数大于允许的最大集合个数时，则会执行LRU淘汰算法。 所有的元素在LRUMap中会根据最近使用情况进行排序。最近使用的会放在元素的最前面(LRUMap是通过链表来存储元素内容). 所以LRUMap进行淘汰时只需要删除链表最后一个即可（即header.after所指的元素对象）

影响元素的使用情况的操作：

* 1.put 当新增加一个集合元素对象，则表示该对象是最近被访问的
* 2.get 操作会把当前访问的元素对象作为最近被访问的，会被移到链接表头

注：当执行containsKey和containsValue操作时，不会影响元素的访问情况。

```java
@Test
public void testLRUMap(){
    LRUMap lruMap = new LRUMap(2);
    //因为LRUMap是非线程安全，所以可以使用
    // Collections.synchronizedMap(map)来保证线程安全
    Map map = Collections.synchronizedMap(lruMap);
    lruMap.put("boy", "ay");
    lruMap.put("girl", "al");
    lruMap.get("boy");//最近使用
    lruMap.put("person", "person");
    System.out.println(lruMap);//{boy=ay, person=person}
}
```

### 4.多个关键字经过组合映射map：MultiKeyedMap

根据API文档，MultiKeyedMap可以通过下面方式进行什么：

//创建一个排序的map

MultiKeyMap.decorate(new LinkedMap()) creates an ordered map.

MultiKeyMap.decorate(new LRUMap()) creates an least recently used map.

MultiKeyMap.decorate(new ReferenceMap()) creates a garbage collector sensitive map.

```java
  @Test
  public void testMultiKeyMap(){
      //初始化类
      MultiKeyMap multiKeyMap = MultiKeyMap.decorate(new LinkedMap());
      multiKeyMap.put(1,1,2,"112");
      multiKeyMap.put(1,1,3,"113");
      multiKeyMap.put(1,2,1,"121");
      multiKeyMap.put(1,2,2,"122");
      multiKeyMap.put(1,3,1,"131");
      //查找一个值:由1，1，2这3个key可以获得唯一的value值
      String value = (String)multiKeyMap.get(1,1,2);
      System.out.println("value is : " + value);//value is : 112
      String value3 = (String)multiKeyMap.get(2,1,1);
      System.out.println("value3 is : " + value3);//value3 is : null
      String value2 = (String)multiKeyMap.get(1,2,1);
      System.out.println("value2 is " + value2);//value2 is 121
      Object object1 = multiKeyMap.get(1);
      System.out.println("object1 is : " + object1);//object1 is : null
      Object object2 = multiKeyMap.get(1,2);
      System.out.println("object2 is : " + object2);//object2 is : null
  }
```

### 5.允许Key重复的Map：IdentityHashMap

IdentityHashMap允许地址不同但内容相等作为key值，换句话说，在 IdentityHashMap 中，当且仅当 (k1==k2) 时，才认为两个键 k1 和 k2 相等。具体例子如下：

```java
@Test
public void testIdentityMap(){
    class Boy{
        private int id;
        private String name;
        public Boy(int id, String name) {
            this.id = id;
            this.name = name;
        }
        public int getId() {
            return id;
        }
        public void setId(int id) {
            this.id = id;
        }
        public String getName() {
            return name;
        }
        public void setName(String name) {
            this.name = name;
        }
        @Override
        public String toString() {
            return "Boy{" +
                    "id=" + id +
                    ", name='" + name + '\'' +
                    '}';
        }
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Boy boy = (Boy) o;
            if (id != boy.id) return false;
            return name != null ? name.equals(boy.name) : boy.name == null;
        }
        @Override
        public int hashCode() {
            int result = id;
            result = 31 * result + (name != null ? name.hashCode() : 0);
            return result;
        }
    }
    //初始化
    IdentityMap identityMap = new IdentityMap();
    //key是相同的boy对象，内存地址不同，但是内容相同
    identityMap.put(new Boy(1,"ay"),"ay");
    identityMap.put(new Boy(1,"ay"),"al");
    System.out.println(identityMap);//{Boy{id=1, name='ay'}=al, Boy{id=1, name='ay'}=ay}
    //初始化正常map
    Map map = new HashedMap();
    //因为我们有重写hashCode方法和toString方法
    map.put(new Boy(1,"ay"),"ay");
    map.put(new Boy(1,"ay"),"al");
    System.out.println(map);//{Boy{id=1, name='ay'}=al}
}
```

### 6.线程安全的map：ConcurrentMap

ConcurrentHashMap是HashMap的线程安全版本，ConcurrentSkipListMap是TreeMap的线程安全版本。

ConcurrentHashMap和ConcurrentSkipListMap应尽量多的使用。



