---

title: "java基础复习三Java对象与类"
key: java基础
tags: java基础 对象
author: jv0id
---



## 类

- 面向对象程序设计（简称OOP），Java是完全面向对象的
- 类（class）是构造对象的模板或蓝图，由类构造对象的过程称为创建类的实例
- 封装是将数据和行为组合在一个包中，并对对象的使用者隐藏了数据的实现方式。数据称为实例域，操纵数据的过程称为方法。实现封装的关键在于绝对不能让类中的方法直接访问其他类的实例域。这是提高重用性和可靠性的关键。
- 定义类的属性：修饰符 类型 属性名 = 初值 ;
- 定义类的方法：修饰符 返回值类型 方法名 ( 参数列表) { 方法体语句； }，所有方法都必须在类的内部定义

## 类之间的关系

- 依赖：应该尽可能的将相互依赖的类减至最少（耦合度最小）
- 聚合：类A的对象包含类B的对象
- 继承：子类继承父类，拥有父类方法的同时还可以定义自己的方法

## 用户自定义类

- 在一个源文件中，只能有一个公有类，但可以有任意数目的非公有类。
- this代表本类，为隐式参数

### 构造器

- 构造器与类同名，在构造类的对象时，构造器会运行，将实例域初始化为希望的状态
- 构造器总是伴随着new操作符的执行被调用
- 每个类可以有一个以上的构造器
- 构造器可以有0个，1个或多个参数
- 构造器没有返回值
- 修饰符一般为public

### 静态域和静态方法

- 如果把域定义为static，如：static｛...｝每个类中只有一个这样的域，它属于类，而不属于任何独立的对象
- 在类第一次加载的时候，将会进行静态域的初始化
- 所有的静态初始化语句及静态初始化块都将依照类定义的顺序执行
- 静态方法是一种不能向对象实施操作的方法，建议使用类名，而不是对象来调用静态方法
- 使用静态方法的情况有两种，一种是一个方法不需要访问对象状态，其所需参数都是通过显式参数提供。另一种是一个方法只需要访问类的静态域

### 方法参数

- Java程序设计语言总是采用按值调用（表示方法接收的是调用者提供的值）
- 按引用调用（表示方法接受的是调用者提供的变量地址）
- 一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值
- 方法参数共有两种类型：一种是基本数据类型（数字，布尔值）,另一种是对象引用
- 一个方法不可能修改一个基本数据类型的参数（数值型和布尔型）
- 方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象
- 对象引用进行的是值传递
- 一个方法可以改变一个对象参数的状态
- 一个方法不能让对象参数引用一个新的对象

## 类加载过程

![](https://raw.githubusercontent.com/jv0id/jv0id.github.io/master/images/leijiazai.png)

- 首先cong.java生成了.class文件
- 要运行程序，首先虚拟机里会有一个类加载器（class loader），把类加载到虚拟机里去，存到静态方法区里面了
- 方法区就是上面的静态方法区。
- 执行引擎：检索堆的：回收垃圾、怎么运行堆等；本地方法接口：提供给计数器用的。最后再加上本地方法库。

## 对象

面向对象的三大特征：封装，继承，多态

对象的三个主要特性：

- 对象的行为：可以对对象施加哪些操作或哪些方法。
- 对象的状态：当施加方法时，对象如何响应。
- 对象标识：如何辨别具有相同行为与状态的不同对象。

Java中通过将数据声明为私有的(`private`)，再提供公共的（`public`）方法:getXxx()和setXxx()实现对该属性的操作，以实现下述目的：

- 隐藏一个类中不需要对外提供的实现细节
- 使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作
- 便于修改，增强代码的可维护性

### 对象构造

- 如果多个方法有相同的名字，不同的参数，就产生了重载
- Java允许重载任何方法，而不只是构造器方法。
- 如果在构造器中没有显式的给域赋值，那么就会被自动的赋为默认值：数值为`0`，布尔型为`false`，对象引用为`null`
- 很多类都包含一个无参数的构造函数，对象由无参数构造函数创建时，其状态会设置为适当的默认值
- 如果在编写一个类时没有编写构造器，那么系统就会提供一个无参数的构造器
- 如果类中提供了至少一个构造器，但是没有提供无参数的构造器，则在构造对象时如果没有提供参数就会被视为不合法
- 仅当类没有提供任何构造器的时候，系统才会提供一个默认的构造器
- 在执行构造器之前，先执行赋值操作，初始值不一定是常量
- 如果构造器的第一个语句为：this（...），这个构造器将调用同一个类的另一个构造器。
- 调用构造器的具体处理步骤：
- 1）所有数据域被初始化为默认值（`0`，`false`，`null`）
- 2）按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块
- 3）如果构造器第一行调用了第二个构造器，则执行第二个构造器主体
- 4）执行这个构造器主体

### 初始化块

- 初始化块由`{}`组成，只要构造类的对象，这些块就会被执行
- 首先运行初始化块，然后才运行构造器的主体部分
- 调用

### 对象析构

- 由于Java有自动的垃圾回收器，不需要人工回收内存，所以Java不支持析构器
- 可以为任何一个类添加finalize方法，finalize方法将会在垃圾回收器清除对象之前调用

### 对象内存解析

[类和对象内存解析](https://blog.csdn.net/silent0001/article/details/89606204)

## 类设计技巧

- 一定要保证数据私有（绝对不要破坏封装性）
- 一定要对数据初始化（Java不对局部变量进行初始化，但是会对对象的实例域进行初始化）
- 不要在类中使用过多的基本类型
- 不是所有的域都需要独立的域访问器和域更改器
- 将职责过多的类进行分解
- 类名和方法名要能够体现他们的职责



## 面向对象设计原则

- 开-闭原则（目标、总的指导思想）Open Closed Principle：对扩展开放，对修改关闭。增加新功能，不改变原有代码。
- 类的单一职责（一个类的定义）Single ResponsibilityPrinciple：一个类有且只有一个改变它的原因。适用于基础类，不适用基于基础类构建复杂的聚合类。
- 依赖倒置（依赖抽象）Dependency Inversion Principle：客户端代码(调用的类)尽量依赖(使用)抽象的组件。抽象的是稳定的。实现是多变的。
- 组合复用原则（复用的最佳实践）Composite Reuse Principle：如果仅仅为了代码复用优先选择组合复用，而非继承复用。组合的耦合性相对继承低。
- 里氏替换（继承后的重写，指导继承的设计）Liskov Substitution Principle：父类出现的地方可以被子类替换，在替换后依然保持原功能。子类要拥有父类的所有功能。子类在重写父类方法时，尽量选择扩展重写，防止改变了功能。
- 接口隔离（功能拆分） Interface Segregation Principle：尽量定义小而精的接口interface，少定义大而全的接口。本质与单一职责相同，小接口之间功能隔离，实现类需要多个功能时可以选择多实现或接口之间做继承。
- 面向接口编程而非面向实现（切换、并行开发）：客户端通过一系列抽象操作实例，而无需关注具体类型。便于灵活切换一系列功能。实现软件的并行开发。
- 迪米特法则（类与类交互的原则）Law of Demeter：类与类交互时，在满足功能要求的基础上，传递的数据量越少越好。因为这样可能降低耦合度。

