---
title: "java面试"
layout: post
date: 2018-04-26 22:48
tag:
- 面试
- java
---


### OOP

- OOP面向对象编程

```
Java 是一个支持并发、基于类和面向对象的计算机编程语言。下面列出了面向对象软件开发的优点：

代码开发模块化，更易维护和修改。 
代码复用。 
增强代码的可靠性和灵活性。 
增加代码的可理解性。 
面向对象编程有很多重要的特性，比如：封装，继承，多态和抽象
```

```
使用封装的一些好处：

通过隐藏对象的属性来保护对象内部的状态。 
提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。 
禁止对象之间的不良交互提高模块化。
```

```
抽象和封装的不同点:

抽象和封装是互补的概念。一方面，抽象关注对象的行为。另一方面，封装关注对象行为的细节。一般是通过隐藏对象内部状态信息做到封装，因此，封装可以看成是用来提供抽象的一种策略。
```





### java问题

```
1.什么是 Java 虚拟机？为什么 Java 被称作是“平台无关的编程语言”？

java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。Java 源文件被编译成能被 Java 虚拟机执行的字节码文件。
Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。
JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。
```

```
2.JDK 和 JRE 的区别是什么？

Java 运行时环境(JRE)是将要执行 Java 程序的 Java 虚拟机。它同时也包含了执行 applet 需要的浏览器插件。Java 开发工具包(JDK)是完整的 Java 软件开发包，包含了 JRE，编译器和其他的工具(比如：JavaDoc，Java 调试器)，可以让开发者开发、编译、执行 Java 应用程序。
```

```
3.”static”关键字是什么意思？Java 中是否可以覆盖(override)一个static方法？

“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。
Java 中 static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的。static 方法跟类的任何实例都不相关，所以概念上不适用。 
```

```
4.是否可以在 static 环境中访问非 static 变量？

static 变量在 Java 中是属于类的，它在所有的实例中的值是一样的。当类被 Java 虚拟机载入的时候，会对 static 变量进行初始化。如果你的代码尝试不用实例来访问非 static 的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。
```

```
5.Java 支持的数据类型有哪些？什么是自动拆装箱？

Java 语言支持的 8 中基本数据类型是： 
byte 
short 
int 
long 
float 
double 
boolean 
char 
自动装箱是 Java 编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把 int 转化成 Integer，double 转化成 double，等等。反之就是自动拆箱。 
```

```
6.Java 中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？

Java 中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。
与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。
```

```
7.Java 中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？

当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java 编译器会为这个类创建一个默认的构造函数。
Java 中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。
Java 不支持像 C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java 不会创建默认的复制构造函数。 
```

```
8.Java 支持多继承么？

不支持，Java 不支持多继承。每个类都只能继承一个类，但是可以实现多个接口。 
```

```
9.接口和抽象类的区别是什么？

接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。 类可以实现很多个接口，但是只能继承一个抽象类 
类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。 
抽象类可以在不提供接口方法实现的情况下实现接口。 
Java 接口中声明的变量默认都是 final 的。抽象类可以包含非 final 的变量。 
Java 接口中的成员函数默认是 public 的。抽象类的成员函数可以是 private，protected 或者是 public。 
接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含 main方法的话是可以被调用的。 
```

```
10.什么是值传递和引用传递？

对象被值传递，意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响源对象的值。
对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象所做的改变会反映到所有的对象上。
```

```
4、float f=3.4;是否正确？

答:不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成float f =3.4F;。
```

```
9、解释内存中的栈(stack)、堆(heap)和静态区(static area)的用法。 
答：
基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；
通过new关键字和构造器创建的对象放在堆空间；
程序中的字面量（literal）如直接书写的100、"hello"和常量都是放在静态区中。
栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，理论上整个内存没有被其他进程使用的空间甚至硬盘上的虚拟内存都可以被当成堆空间来使用。

```

```
11、switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？ 
答：在Java 5以前，switch(expr)中，expr只能是byte、short、char、int。从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型，从Java 7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。

```

```
12、用最有效率的方法计算2乘以8？ 
答： 
2 << 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。

```

```
13、数组有没有length()方法？String有没有length()方法？ 
答：数组获取长度的手段是 .length 属性；String获取长度的手段是 length()方法；集合获取长度的手段是 size()方法；文件获取长度的手段是 length()方法

```

```
14、在Java中，如何跳出当前的多重嵌套循环？ 
答：在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环。（Java中支持带标签的break和continue语句，作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好）

```

```
16、两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？ 
答：不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同。

```

```
17、是否可以继承String类？ 
答：String 类是final类，不可以被继承。简单的来说：String 类中使用 final 关键字字符数组保存字符串，private　final　char　value[]，所以 String 对象是不可变的。

17、字符串拼接原理：
答：运行时， 两个字符串str1, str2的拼接首先会调用 String.valueOf(obj)，这个Obj为str1，而String.valueOf(Obj)中的实现是return obj == null ? “null” : obj.toString(), 然后产生StringBuilder，调用的StringBuilder(str1)构造方法，把StringBuilder初始化，长度str1.length()+16，并且调用append(str1)！ 接下来调用StringBuilder.append(str2), 把第二个字符串拼接进去， 然后调用StringBuilder.toString返回结果！
```

```
18、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？ 
答：JAVA中没有引用传递，是值传递。

```

```
19、String和StringBuilder、StringBuffer的区别？ 
答String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。StringBuffer/StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是Java 5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer要高。
```

```
21、描述一下JVM加载class文件的原理机制？ 
答：JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，它负责在运行时查找和装入类文件中的类。 
Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这样可以节省内存开销
类装载方式，有两种 
    　　1.隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中，
    　　2.显式装载， 通过class.forname()等方法，显式加载需要的类

```

```
22、char 型变量中能不能存贮一个中文汉字，为什么？ 
答：char类型可以存储一个中文汉字，因为Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个char类型占2个字节（16比特），所以放一个中文是没问题的。
```

```
Java 的八种基本数据类型，每个占多少个字节？

bit --位：位是计算机中存储数据的最小单位，指二进制数中的一个位数，其值为“0”或“1”。
byte --字节：字节是计算机存储容量的基本单位，一个字节由8位二进制数组成。在计算机内部，一个字节可以表示一个数据，也可以表示一个英文字母，两个字节可以表示一个汉字。
1Byte=8bit  (1B＝8bit)

byte     8bit=1byte
short   16bit=2byte
int     32bit=4byte
long    64bit=8byte
float   32bit=4byte
double   64bit=8byte
boolean 1bit
char     16bit=2byte
```

```
short s1 = 1; s1 = s1 + 1;有什么错?

short s1=1;这一句没有错误，编译器自动把1从整形处理为short
s1=s1+1; 右侧的表达式会返回一个int类型的整数，再把这个int类型的整数赋值给short类型的s1的时候，就会出现类型强制转换错误
```

```
Math.round(11.5)等于多少? Math.round(-11.5)等于多少?

Math.round 的意思是+0.5 取整数
所以 Math.round(11.5) 即 11.5+0.5 = 12
Math.round(-11.5) 即 -11.5+0.5 = -11
```

```
String s = new String("xyz");创建了几个String Object?

首先构造方法 new String("xyz"); 中的"xyz" 这本身就是一个字符串对象
然后 new 关键字一定会创建一个对象
所以总共创建了两个String对象
```

```
接口可以继承接口？
抽象类能实现接口？
抽象类能继承实体类？

接口可以继承接口，比如list继承了Collection
抽象类可以实现接口，比如适配器实现了监听器接口
抽象类可以继承实体类，比如所有抽象类都继承了Object
```

```
抽象方法是否可以同时是static，是否可以同时是synchronized？

都不可以
```

```
解析XML文档有哪几种方式？

主要是两种，SAX和DOM
SAX 就是逐行读取，直到找到目标数据为止
DOM 是先全文档加载，然后读取
```

```
为什么java是单继承，但却是多实现的呢？

java是单继承是因为一个类只能有一个直接父类；如果类A有一个print方法，类B也有一个print方法，类C继承了A和B，那么当调用new C().print()方法时就不知道是调用的哪一个类的了

但是对于接口的实现，一个类却能够实现多个接口，接口是用来扩展对象的功能的，即便两个接口中存在相同的抽象函数。但在实现时，我们只能在当前类中实现一个这样的函数，所以不论是实现的哪个，另外一个同名的也就无所谓了。于是，java就是多实现的了。
```

```
什么是java序列化，如何实现java序列化？

序列化是指把一个java对象，通过某种介质进行传输，比如socket输入输出流，或者保存在一个文件里
实现java序列化的手段是让该类实现Serializable接口，这个接口是一个标识性接口，没有任何方法，仅仅用于表示该类可以序列化
```





### java线程

```
11.进程和线程的区别是什么？

进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。
```

```
12.创建线程有几种不同的方式？你喜欢哪一种？为什么？

有三种方式可以用来创建线程： 
继承 Thread 类 
实现 Runnable 接口 
使用匿名类
应用程序可以使用 Executor 框架来创建线程池 
实现 Runnable 接口这种方式更受欢迎，因为这不需要继承 Thread 类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而 Java 不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。
```

```
13.概括的解释下线程的几种可用状态。

就绪(Runnable):线程准备运行，不一定立马就能开始执行。 运行中(Running)：进程正在执行线程的代码。 
等待中(Waiting):线程处于阻塞的状态，等待外部的处理结束。 睡眠中(Sleeping)：线程被强制睡眠。 
I/O 阻塞(Blocked on I/O)：等待 I/O 操作完成。 
同步阻塞(Blocked on Synchronization)：等待获取锁。 
死亡(Dead)：线程完成了执行。 
```

```
14.同步方法和同步代码块的区别是什么？

在 Java 语言中，每一个对象有一把锁。线程可以使用 synchronized 关键字来获取对象上的锁。 synchronized 关键字可应用在方法级别(粗粒度锁)或者是代码块级别(细粒度锁)。
```

```
15.在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？

监视器和锁在 Java 虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。
```

```
16.什么是死锁(deadlock)？

两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程都陷入了无限的等待中。 
```

```
17.如何确保 N 个线程可以访问 N 个资源同时又不导致死锁？

使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。
```

```
线程同步的机制?

线程同步有4种机制：临界区,互斥量,事件,信号量
临界区：临界区是一段独占对某些共享资源访问的代码，在任意时刻只允许一个线程对共享资源进行访问。如果有多个线程试图同时访问临界区，那么在有一个线程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操作共享资源的目的。 
PS:私人浴室（没有管理员）只有一间淋浴房，我想洗澡，我时不时来看下淋浴房空了没，空了我就去洗。

互斥量：功能上跟临界区类似，不过可用于不同进程间的线程同步。
PS:公共浴室(有管理员）只有一间淋浴房，我想洗澡，问了下管理员，有空的淋浴房么，如果有，管理员就让我洗，否则管理员就让我先去休息室睡一觉，等有空的淋浴房了叫醒我去洗澡。

事件：触发重置事件对象，那么等待的所有线程中将只有一个线程能唤醒，并同时自动的将此事件对象设置为无信号的；它能够确保一个线程独占对一个资源的访问。和互斥量的区别在于多了一个前置条件判定。
PS:公共浴室(有管理员）只有一间淋浴房，我想洗澡，问了下管理员，有空的淋浴房么，如果淋浴房没人洗而且打扫完了(等待的事件），管理员就让我洗，否则管理员就让我先去休息室睡一觉，等没人洗而且打扫完了叫醒我去洗澡。

信号量：信号量用于限制对临界资源的访问数量，保证了消费数量不会大于生产数量。
PS:公共浴室(有管理员）有N间（资源数量限制）淋浴房，我想洗澡，问了下管理员，有空的淋浴房么，如果有，管理员就让我洗，否则管理员就让我先去休息室睡一觉，等有空的淋浴房了叫醒我去洗澡。
```

```
同步和异步的区别?

同步（Sync）:所谓同步，就是发出一个功能调用时，在没有得到结果之前，该调用就不返回或继续执行后续操作。

异步（Async）:异步与同步相对，当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作。当这个调用完成后，一般通过状态、通知和回调来通知调用者。对于异步调用，调用的返回并不受调用者控制。 
```

```
阻塞和非阻塞的区别?

阻塞就是干不完不准回来,阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。
非阻塞就是你先干，我现看看有其他事没有，完了告诉我一声,
```

```
操作系统中死锁的四个必要条件?

互斥条件：进程对分配给它的资源进行排它性使用，即在一段时间内某一个资源只能由一个进程使用。如果其他进程申请使用该资源则必须等待，直到拥有者释放该资源；

请求和保持条件：进程已经至少保持了一个资源，但是又提出了新的资源请求，该资源又被其他进程占用，此进程被阻塞，但是并没有释放自己拥有的资源

不可抢占条件：分配给进程的资源，除非进程自己释放，否则其他进程不可抢占

循环等待：发生死锁时，必然存在一个进程-资源的循环链
只要破坏四个条件中的一个，就能阻止死锁情况的发生
```





### java集合类

```
18.Java 集合类框架的基本接口有哪些？

Java 集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java 集合类里面最基本的接口有： 
Collection：代表一组对象，每一个对象都是它的子元素。 
Set：不包含重复元素的 Collection。
List：有顺序的 collection，并且可以包含重复元素。 
Map：可以把键(key)映射到值(value)的对象，键不能重复。 
```

```
19.为什么集合类没有实现 Cloneable 和 Serializable 接口？

集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。 
```

```
20.什么是迭代器(Iterator)？

Iterator 接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的 
迭代方法。迭代器可以在迭代的过程中删除底层集合的元素。 
```

```
21.Iterator 和 ListIterator 的区别是什么？

Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。 
Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。 
ListIterator 实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。
```

```
22.快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？

Iterator 的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util.concurrent 包下面的所有的类都是安全失败的。

java.util包下面的所有的集合类都是快速失败的，迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。 
```

[安全失败与快速失败](https://www.cnblogs.com/songanwei/p/9387745.html)



```
23.Java 中的 HashMap 的工作原理是什么？

Java 中的 HashMap 是以键值对(key-value)的形式存储元素的。HashMap 需要一个 hash 函数，它使用 hashCode()和 equals()方法来向集合/从集合添加和检索元素。当调用 put()方法的时候，HashMap 会计算 key 的 hash 值，然后把键值对存储在集合中合适的索引上。如果 key已经存在了，value 会被更新成新值。HashMap 的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。
```

```
24.hashCode()和 equals()方法的重要性体现在什么地方？

Java 中的 HashMap 使用 hashCode()和 equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash 值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对 HashMap 的精确性和正确性是至关重要的。
```

```
25.HashMap 和 Hashtable 有什么区别？

HashMap 允许键和值是 null，而 Hashtable 不允许键或者值是 null。 
Hashtable 是同步的，而 HashMap 不是。因此，HashMap 更适合于单线程环境，而 Hashtable适合于多线程环境。 
HashMap 提供了可供应用迭代的键的集合，因此，HashMap 是快速失败的。另一方面， Hashtable 提供了对键的列举(Enumeration)。 
一般认为 Hashtable 是一个遗留的类。
```

```
26.数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用 Array 而不是 ArrayList？

Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。 
Array 大小是固定的，ArrayList 的大小是动态变化的。 
ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。 
对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。 
```

```
27.ArrayList 和 LinkedList 有什么区别？

ArrayList 和 LinkedList 都实现了 List 接口
ArrayList 是基于索引的数据接口，它的底层是数组。它可以以 O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList 是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是 O(n)。 
相对于 ArrayList，LinkedList 的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。 
LinkedList 比 ArrayList 更占内存，因为 LinkedList 为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。
```

```
28.Comparable 和 Comparator 接口是干什么的？列出它们的区别。

Java 提供了只包含一个 compareTo()方法的 Comparable 接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。
Java 提供了包含 compare()和 equals()两个方法的 Comparator 接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和 comparator 相等。只有当输入参数也是一个 comparator 并且输入参数和当前 comparator 的排序结果是相同的时候，这个方法才返回 true。 
```

```
29.什么是 Java 优先级队列(Priority Queue)？

PriorityQueue 是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)排序的。在创建的时候，我们可以给它提供一个负责给元素排序的比较器。PriorityQueue 不允许null 值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，PriorityQueue不是线程安全的，入队和出队的时间复杂度是 O(log(n))。
```

```
31.如何权衡是使用无序的数组还是有序的数组？

有序数组最大的好处在于查找的时间复杂度是 O(log n)，而无序数组是 O(n)。有序数组的缺点是插入操作的时间复杂度是 O(n)，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量 O(1)。
```

```
32.Java 集合类框架的最佳实践有哪些？

根据应用的需要正确选择要使用的集合的类型对性能非常重要，比如：假如元素的大小是固定的，而且能事先知道，我们就应该用 Array 而不是 ArrayList。 
有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算 hash 值或者是扩容。 
为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的 ClassCastException。 
使用 JDK 提供的不变类(immutable class)作为 Map 的键可以避免为我们自己的类实现hashCode()和 equals()方法。 
编程的时候接口优于实现。 
底层的集合实际上是空的情况下，返回长度是 0 的集合或者是数组，不要返回 null。
```

```
33.Enumeration 接口和 Iterator 接口的区别有哪些？

Enumeration 速度是 Iterator 的 2 倍，同时占用更少的内存。但是，Iterator 远远比 Enumeration安全，因为其他线程不能够修改正在被 iterator 遍历的集合里面的对象。同时，Iterator 允许调用者删除底层集合里面的元素，这对 Enumeration 来说是不可能的。
```

```
34.HashSet 和 TreeSet 有什么区别？

HashSet 是由一个 hash 表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是 O(1)。 
另一方面，TreeSet 是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()， remove()，contains()方法的时间复杂度是 O(logn)。
```

```
String 和StringBuffer的区别？

String是immutable的,其内容一旦创建好之后，就不可以发生改变。
StringBuffer 是可以变长的，内容也可以发生改变
改变的原理是StringBuffer内部采用了字符数组存放数据，在需要增加长度的时候，创建新的数组，并且把原来的数据复制到新的数组这样的办法来实现。 
更多细节可以参考 模仿StringBuffer的 MyStringBuffer 类是如何实现的。
```

```
ArrayList是否是线程安全的？

是线程不安全的。ArrayList的实现主要就是用了一个Object的数组，用来保存所有的元素，以及一个size变量用来保存当前数组中已经添加了多少元素。
在多个线程进行add操作时可能会导致elementData数组越界
```

```
判断一个集合类是否为线程安全的机制是什么？

看多个线程同时访问该类中的一个成员变量，是否需要枷锁,可以说，没有线程安全的类，即多线程访问的时候，几乎都需要加锁
```

```
为什么 JDK 1.7 是头插法，JDK 1.8 是尾插法？

头插法是操作速度最快的，找到数组位置就直接找到插入位置了，jdk8之前hashmap这种插入方法在并发场景下如果多个线程同时扩容会出现循环列表。
jdk8开始hashmap链表在节点长度达到8之后会变成红黑树，这样一来在数组后节点长度不断增加时，遍历一次的次数就会少很多很多（否则每次要遍历所有），相比头插法而言，尾插法操作额外的遍历消耗已经小很多了，也可以避免之前的循环列表问题。
```

```
怎么避免或者减少哈希碰撞 ？

1:开放地址法
2：再哈希法：当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时
3：链表法：将所有关键字为同义词的记录存储在同一线性链表中
4：建立一个公共溢出区
```

[解决哈希冲突](https://www.cnblogs.com/little-fly/p/7907935.html)

```
heap和stack有什么区别？

heap：堆，是存放对象的，是自动增加大小的，所以不需要指定大小，但是存取相对较慢
stack：栈，是存放基本数据类型，引用（对象地址），方法调用。是固定大小的，并且是先入后出的顺序，并且存取速度比较快
```

```
Set里的元素是不能重复的，那么用什么方法来区分重复与否呢?

1:首先看hashcode是否相同，如果不同，就是不重复的
2：如果hashcode相同，再比较equals，如果不同，就是不重复的，否则就是重复的
```

[hashcode原理](http://how2j.cn/k/collection/collection-hashcode/371.html)



### 垃圾回收

```
35.Java 中垃圾回收有什么目的？什么时候进行垃圾回收？

垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。
```

```
36.System.gc()和 Runtime.gc()会做什么事情？

这两个方法用来提示 JVM 要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于 JVM 的。
```

```
37.finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？

在释放对象占用的内存之前，垃圾收集器会调用对象的 finalize()方法。一般建议在该方法中释放对象持有的资源。
```

```
38.如果对象的引用被置为 null，垃圾收集器是否会立即释放对象占用的内存？

不会，在下一个垃圾回收周期中，这个对象将是可被回收的。
```

```
39.Java 堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)?

JVM 的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在 JVM 启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。 
堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些对象回收掉之前，他们会一直占据堆内存空间。
```

```
40.串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？

吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。而串行收集器对大多数的小应用(在现代处理器上需要大概 100M 左右的内存)就足够了。
```

```
41.在 Java 中，对象什么时候可以被垃圾回收？

当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。
```

```
42.JVM 的永久代中会发生垃圾回收么？

垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免 Full GC 是非常重要的原因。
```





### 异常处理

```
43.Java 中的两种异常类型是什么？他们有什么区别？

Java 中有两种异常：受检查的(checked)异常和不受检查的(unchecked)异常。不受检查的异常不需要在方法或者是构造函数上声明，就算方法或者是构造函数的执行可能会抛出这样的异常，并且不受检查的异常可以传播到方法或者是构造函数的外面。相反，受检查的异常必须要用 throws 语句在方法或者是构造函数上声明。
```

```
44.Java 中 Exception 和 Error 有什么区别？

Exception 和 Error 都是 Throwable 的子类。Exception 用于用户程序可以捕获的异常情况。Error定义了不期望被用户程序捕获的异常。
```

```
45.1 throw 和 throws 有什么区别？

throw 关键字用来在程序中明确的抛出异常，相反，throws 语句用来表明方法不能处理的异常。每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。
```

```
45.2 异常处理的时候，finally 代码块的重要性是什么？

无论是否抛出异常，finally 代码块总是会被执行。就算是没有 catch 语句同时又抛出异常的情况下，finally 代码块仍然会被执行。最后要说的是，finally 代码块主要用来释放资源，比如：I/O 缓冲区，数据库连接。
```

```
46.异常处理完成以后，Exception 对象会发生什么变化？

Exception 对象会在下一个垃圾回收过程中被回收掉。 
```

```
47.finally 代码块和 finalize()方法有什么区别？

无论是否抛出异常，finally 代码块都会执行，它主要是用来释放应用占用的资源。finalize()方法是 Object 类的一个 protected 方法，它是在对象被垃圾回收之前由 Java 虚拟机来调用的。
```

```
try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后?

try里的return 和 finally里的return 都会执行，但是当前方法只会采纳finally中return的值
```

```
请列举五个最常见的runtime exception？

NullPointerException 空指针异常
ArithmeticException 算术异常，比如除数为零
ClassCastException 类型转换异常
ConcurrentModificationException 同步修改异常，遍历一个集合的时候，删除集合的元素，就会抛出该异常 
IndexOutOfBoundsException 数组下标越界异常
NegativeArraySizeException 为数组分配的空间是负数异常
```





### JDBC

```
72.什么是 JDBC？

JDBC 是允许用户在不同数据库之间做选择的一个抽象层。JDBC 允许开发者用 JAVA 写数据库应用程序，而不需要关心底层特定数据库的细节。
```

```
73.解释下驱动(Driver)在 JDBC 中的角色。

JDBC 驱动提供了特定厂商对 JDBC API 接口类的实现，驱动必须要提供 java.sql 包下面这些类的实现：Connection, Statement, PreparedStatement,CallableStatement, ResultSet 和 Driver。
```

```
74.Class.forName()方法有什么作用？

这个方法用来载入跟数据库建立连接的驱动。 
```

```
75.PreparedStatement 比 Statement 有什么优势？

PreparedStatements 是预编译的，因此，性能会更好。同时，不同的查询参数值， PreparedStatement 可以重用。
```

```
76.什么时候使用 CallableStatement？用来准备 CallableStatement 的方法是什么？

CallableStatement 用来执行存储过程。存储过程是由数据库存储和提供的。存储过程可以接受输入参数，也可以有返回结果。非常鼓励使用存储过程，因为它提供了安全性和模块化。
准备一个 CallableStatement 的方法是： 
CallableStament.prepareCall();
```

```
77.数据库连接池是什么意思？

像打开关闭数据库连接这种和数据库的交互可能是很费时的，尤其是当客户端数量增加的时候，会消耗大量的资源，成本是非常高的。可以在应用服务器启动的时候建立很多个数据库连接并维护在一个池中。连接请求由池中的连接提供。在连接使用完毕以后，把连接归还到池中，以用于满足将来更多的请求。 
```

```
数据库连接池的工作机制是什么？

因为创建连接和关闭连接的行为是非常耗时的，会显著降低软件的性能表现。解决办法就是先创建N条数据库连接Connection，循环使用，但是不进行关闭，这样再执行sql语句，就不需要额外创建连接了，直接使用现成的连接就可以了，从而节约了创建连接和关闭连接的时间开销。
```





### RMI

```
78.什么是 RMI？

Java 远程方法调用(Java RMI)是 Java API 对远程过程调用(RPC)提供的面向对象的等价形式，支持直接传输序列化的 Java 对象和分布式垃圾回收。远程方法调用可以看做是激活远程正在运行的对象上的方法的步骤。RMI 对调用者是位置透明的，因为调用者感觉方法是执行在本地运行的对象上的
```

```
79.RMI 体系结构的基本原则是什么？

RMI 体系结构是基于一个非常重要的行为定义和行为实现相分离的原则。RMI 允许定义行为的代码和实现行为的代码相分离，并且运行在不同的 JVM 上。 
```

```
80.RMI 体系结构分哪几层？

存根和骨架层(Stub and Skeleton layer)：这一层对程序员是透明的，它主要负责拦截客户端发出的方法调用请求，然后把请求重定向给远程的 RMI 服务。 
远程引用层(Remote Reference Layer)：RMI 体系结构的第二层用来解析客户端对服务端远程对象的引用。这一层解析并管理客户端对服务端远程对象的引用。连接是点到点的。 
传输层(Transport layer)：这一层负责连接参与服务的两个 JVM。这一层是建立在网络上机器间的 TCP/IP 连接之上的。它提供了基本的连接服务，还有一些防火墙穿透策略。
```

```
81.RMI 中的远程接口(Remote Interface)扮演了什么样的角色？

远程接口用来标识哪些方法是可以被非本地虚拟机调用的接口。远程对象必须要直接或者是间接实现远程接口。实现了远程接口的类应该声明被实现的远程接口，给每一个远程对象定义构造函数，给所有远程接口的方法提供实现。
```

```
82.java.rmi.Naming 类扮演了什么样的角色？

java.rmi.Naming 类用来存储和获取在远程对象注册表里面的远程对象的引用。Naming 类的每一个方法接收一个 URL 格式的 String 对象作为它的参数。 
```

```
83.RMI 的绑定(Binding)是什么意思？

绑定是为了查询找远程对象而给远程对象关联或者是注册以后会用到的名称的过程。远程对象可以使用 Naming 类的 bind()或者 rebind()方法跟名称相关联。 
```

```
84.Naming 类的 bind()和 rebind()方法有什么区别？

bind()方法负责把指定名称绑定给远程对象，rebind()方法负责把指定名称重新绑定到一个新的远程对象。如果那个名称已经绑定过了，先前的绑定会被替换掉。
```

```
85.让 RMI 程序能正确运行有哪些步骤？

编译所有的源文件。 
使用 rmic 生成 stub。 
启动 rmiregistry。 
启动 RMI 服务器。 
运行客户端程序。
```

```
86.RMI 的 stub 扮演了什么样的角色？

远程对象的 stub 扮演了远程对象的代表或者代理的角色。调用者在本地 stub 上调用方法，它负责在远程对象上执行方法。当 stub 的方法被调用的时候，会经历以下几个步骤： 
初始化到包含了远程对象的 JVM 的连接。 
序列化参数到远程的 JVM。 
等待方法调用和执行的结果。 
反序列化返回的值或者是方法没有执行成功情况下的异常。 
把值返回给调用者。
```

```
87.什么是分布式垃圾回收(DGC)？它是如何工作的？

DGC 叫做分布式垃圾回收。RMI 使用 DGC 来做自动垃圾回收。因为 RMI 包含了跨虚拟机的远程对象的引用，垃圾回收是很困难的。DGC 使用引用计数算法来给远程对象提供自动内存管理。
```

```
90.解释下 Serialization 和 Deserialization。

Java 提供了一种叫做对象序列化的机制，他把对象表示成一连串的字节，里面包含了对象的数据，对象的类型信息，对象内部的数据的类型信息等等。因此，序列化可以看成是为了把对象存储在磁盘上或者是从磁盘上读出来并重建对象而把对象扁平化的一种方式。反序列化是把对象从扁平状态转化成活动对象的相反的步骤。 
```



### JVM

```
说一下 JVM 的垃圾回收器 CMS和G1？优缺点是什么？

CMS：以获取最短回收停顿时间为目标的收集器，基于并发“标记清理”实现；优点是：并发，低停顿；缺点是：对CPU非常敏感，无法处理浮动垃圾，会产生大量空间碎片

G1：是一款面向服务端应用的垃圾收集器；
```

[垃圾回收器CMS和G1](https://www.cnblogs.com/rgever/p/9534857.html)

```
回收的机制是什么？凭什么判断一个对象会被回收？

垃圾回收（Garbage Collection，GC）,垃圾回收就是释放垃圾占用的空间

平常遇到的比较常见的将对象判定为可回收对象的情况：
1）显示地将某个引用赋值为null或者将已经指向某个对象的引用指向新的对象
Object obj = new Object();
obj = null; obj被回收
Object obj1 = new Object();
Object obj2 = new Object();
obj1 = obj2; obj1被回收

2）局部引用所指向的对象
for(int i=0;i<10;i++) {
        Object obj = new Object();
        System.out.println(obj.getClass());
    }
循环每执行完一次，生成的Object对象都会成为可回收的对象。

3）只有弱引用与其关联的对象
WeakReference<String> wr = new WeakReference<String>(new String("world"));
```

[垃圾回收机制](https://www.cnblogs.com/dolphin0520/p/3783345.html)

```
说一下 GC Roots 包含哪些内容？

1.虚拟机栈中引用的对象 2.本地方法栈中native方法引用的对象 3.方法区中静态属性引用的变量 4.方法区中常量引用的对象 
```

```
什么情况下会发生新生代 gc？

指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 MinorGC 非常频繁，一般回收速度也比较快。对象优先在新生代 Eden 区中分配，如果 Eden 区没有足够的空间时，就会触发一次 Young GC 

```



### 数据结构

```
java中的数据结构？

枚举（Enumeration）
位集合（BitSet）
向量（Vector）
栈（Stack）
字典（Dictionary）
哈希表（Hashtable）
属性（Properties）
```

[java数据结构](https://www.runoob.com/java/java-data-structures.html)



### IO流

```
java中有几种类型的流？

Java中所有的流都是基于字节流，所以最基本的流是
输入输出字节流
InputStream
OutputStream
在字节流的基础上，封装了字符流
Reader
Writer
进一步，又封装了缓存流
BufferedReader
PrintWriter
以及数据流
DataInputStream
DataOutputStream
对象流
ObjectInputStream
ObjectOutputStream
```

